verDeTerre.c : ce programme envoie le signal SIGUSR1 au processus aire pour initialiser le ver. Puis il envoie nb_lig * nb_col fois un signal SIGUSR2 pour se déplacer (rechercher + écrire). Le handler handler_peut_reprendre positionne un booléen à 1 quand verDeTerre reçoit un signal SIGALRM provenant de aire, le processus est mis en attente après l'envoi de SIGUSR2 jusqu'à la réception de SIGALRM, cela évite au processus d'envoyer plein de signaux inutiles (quand le ver ne peut plus se déplacer, aire envoie SIGSTOP au processus, sinon il attend de pouvoir continuer avant de lancer un autre signal SIGUSR2). Problème : le premier ver à écrire dans aire empêche les autre d'écrire tant qu'il ne s'est pas arrêté, et on veut que les vers se déplacement simultanément. C'est pour cette raison que l'implémentation du signal n'est pas faite (code mis en commentaire). Le processus ver envoie donc trop de signaux et cela explique pourquoi SIGSTOP ne fonctionne pas (il est pris en compte après tous les SIGUSR2).

aire.c : ce programme initialise un ver (il ouvre le fichier terrain, marque le ver dans le terrain et l'ajoute à la liste des vers) à la réception du signal SIGUSR1. La liste des vers est gérée par aire. Quand il reçoit le signal SIGUSR2, il identifie le ver qui a envoyé le signal par son pid en regardant dans la liste de vers, il recherche une case libre pour le ver, si elle existe, il écrit dans le fichier terrain et l'affiche, sinon il supprime le ver de la liste des vers et envoie un signal SIGSTOP au ver. Si la liste des vers est vide, c'est à dire quand tous les vers se sont arrêtés, la liste des vers est détruite et le processus aire s'arrête.

Problème qui reste à régler (par manque de temps) : les processus correspondants aux vers arrêtés ne sont pas arrêtés car l'envoi de SIGSTOP est différé à cause de tous les signaux SIGUSR2 (voir problème de verDeTerre.c).
